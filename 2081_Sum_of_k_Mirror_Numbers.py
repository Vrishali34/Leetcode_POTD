class Solution(object):
    def kMirror(self, k, n):
        """
        :type k: int
        :type n: int
        :rtype: int
        """
        total_sum = 0
        count = 0
        
        # Helper function to check if a number is a palindrome in a given base
        def is_palindrome_base_k(num, base):
            if num == 0:
                return True
            
            digits = []
            while num > 0:
                digits.append(num % base)
                num //= base
            
            return digits == digits[::-1]

        # Iterate through possible lengths of the base-10 palindrome
        # Palindromes are generated by their first half
        for length in range(1, 15):  # Length limit to prevent excessively large numbers for typical constraints
            # Calculate the range for the first half of the palindrome
            # For even length: e.g., length 4, first half from 10 to 99 (10^(4/2-1) to 10^(4/2)-1)
            # For odd length: e.g., length 3, first half from 1 to 9 (10^((3-1)/2-1) to 10^((3-1)/2)-1)
            start_half = 10**((length - 1) // 2)
            end_half = 10**(length // 2)

            for i in range(start_half, end_half):
                s_i = str(i)
                # Construct the full palindrome string
                # If length is odd, the middle digit is the last digit of the first half
                # If length is even, simply append the reverse of the first half
                if length % 2 == 1:
                    palindrome_str = s_i + s_i[:-1][::-1]
                else:
                    palindrome_str = s_i + s_i[::-1]
                
                num = int(palindrome_str)

                # Check if the generated number is a k-mirror number
                if is_palindrome_base_k(num, k):
                    total_sum += num
                    count += 1
                    if count == n:
                        return total_sum
        return total_sum
